# port_scanner.py
# By Matthew Wilson
# 12/20/25
# This program is for educational purposes only. 
# Topics: TCP/UDP, Sockets, Timeouts, Error Handling, Firewalls, Multithreading, Service/Banner Detection, CIDR range scanning.
# TODO:
#   - Rewrite in Go
#   - Use argparse for CLI args - DONE (12/20/25)
#   - Add port ranges - DONE (12/20/25)
#   - Output formatting / Output modes (quiet - DONE (12/30/25), grepable, JSON, full packet - DONE (12/30/25)) 
#   - Make all args optional
#   - Expand port arg to scan common groups of ports (all, common, etc)
#   - Better arg help message (add usage)
#   - Batching
#   - Use socket for banners with scapy - DONE (12/30/25)
#   - ICMP filtered handling
#   - CIDR expansion / progress reporting
#   - Use Scapy for SYN mode and full packet output - DONE (12/30/25)
#
# Example Usage Goal: sudo python3 port_scanner.py -t 192.168.1.1 -p 1-1024 -v 1
#
# Issues: 

from scapy.all import IP, TCP, sr, sr1, hexdump

from scapy.layers.inet import ICMP

import socket

import sys
# Imports system-specific functions.
# We use this mainly for sys.exit() to cleanly terminate the program.

import argparse

parser = argparse.ArgumentParser()
parser.add_argument("-t", "--target", help="target ip or hostname to be scanned", required=True)
parser.add_argument("-p", "--ports", help="port(s) to be scanned on target", required=True)
parser.add_argument(
    "-v", "--verbose", 
    type=int, 
    default=1, 
    help="Verbosity level: 0=quiet, 1=normal, 4=full packet", 
    required=False
)
cli = vars(parser.parse_args())

def vprint(level, *args, **kwargs):
        if cli["verbose"] >= level:
            print(*args, **kwargs)

def parse_ports(port_arg):
    try:
        if "-" in port_arg:
            start, end = port_arg.split("-", 1)
            start, end = int(start), int(end)
        
            if not (1 <= start <= 65535 and 1 <= end <= 65535):
                raise ValueError
                
            if start > end:
                raise ValueError("Start port greater then end port")
            
            return range(start, end + 1)
        else:
            port = int(port_arg)
            if not (1 <= port <= 65535):
                raise ValueError
            return [port]
    
    except ValueError:
        vprint(1,"[!] Invalid port specification.")
        sys.exit(2)
    
def scan_port(ip, port):
    try:
        pkt = IP(dst=ip)/TCP(dport=port, flags="S")
        for _ in range(2):
            resp = sr1(pkt, timeout=1, verbose=False)
            if resp:
                break

        if resp is None:
            return port, "filtered", None

        if resp.haslayer(ICMP):
            icmp = resp.getlayer(ICMP)
            if icmp.type == 3:
                return port, "filtered", resp

            
        tcp = resp.getlayer(TCP)
        if tcp is None:
            return port, "non-tcp", resp
        
        if tcp.flags == 0x12:    # SYN-ACK
            # Send RST to close
            rst = IP(dst=ip)/TCP(dport=port, flags="R")
            sr1(rst, timeout=0.5, verbose=False)
            return port, "open", resp
            
        if tcp.flags == 0x14: # RST-ACK
            return port, "closed", resp
            
        return port, "unknown", resp
    
    except PermissionError:
        print("[!] Root privileges required for raw sockets.")
        sys.exit(1)
        
    except Exception as e:
        vprint(1, f"[!] Error scanning port {port}: {e}")
        return port, "error", None

def print_packet(packet):
    if cli["verbose"] >= 4 and packet:
        print(packet.summary())
        hexdump(packet)
    
def banner_grab(ip, port):
    try:
        with socket.create_connection((ip, port), timeout=2) as s:
            banner = s.recv(1024)
            return banner.decode(errors="ignore").strip()
    except (socket.timeout, ConnectionRefusedError):
        return None
    except Exception as e:
        vprint(2, f"[!] Banner error on {port}: {e}")
        return None

def resolve_target(target):
    try:
        return socket.gethostbyname(target)
    except socket.gaierror:
        print(f"[!] Unable to resolve target: {target}")
        sys.exit(2)

def main():
    try: 
        ip = resolve_target(cli["target"])
        
        ports = parse_ports(cli["ports"])
    
        for port in ports:
            port, state, packet = scan_port(ip, port)
            
            if state == "open":
                vprint(0, f"[+] Port {port} open")
                
                banner = banner_grab(ip, port)
                if banner:
                    vprint(1, f"    Banner: {banner}")
                
            print_packet(packet)
    
    except KeyboardInterrupt:
        # Catches Ctrl+C so the program exits cleanly.
        vprint(1, "\n[!] Scan interrupted by user. Exiting.")
        sys.exit(0)
        # Exits normally (exit code 0)
    
    except Exception as e:
        print(f"[!] Fatal error: {e}")
        sys.exit(1)

    vprint(1, "[*] Scan complete.")
    # Indicates the scan finished successfully.

if __name__ == "__main__":
    # ensures main() only runs when the script is executed directly.
    # not when imported as a module. 
    main()
